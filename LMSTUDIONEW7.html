<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>LM Studio WebChat (IndexedDB)</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Segoe UI',-apple-system,BlinkMacSystemFont,sans-serif;background:#1e1e1e;color:#cccccc;height:100vh;display:flex;flex-direction:column;}
.header{background:#2d2d30;border-bottom:1px solid #3e3e42;padding:12px 20px;display:flex;align-items:center;gap:20px;flex-wrap:wrap;}
.title{font-size:16px;font-weight:600;color:#ffffff;}
.connection-group{display:flex;align-items:center;gap:15px;}
.status{display:flex;align-items:center;gap:8px;font-size:14px;}
.status-dot{width:8px;height:8px;border-radius:50%;background:#f14c4c;}
.status-dot.connected{background:#89d185;}
input,select,button{background:#3c3c3c;border:1px solid #5a5a5a;color:#cccccc;padding:6px 12px;border-radius:4px;font-size:14px;}
button{cursor:pointer;transition:background .2s;}
button:hover{background:#4a4a4a;}
button:disabled{opacity:.5;cursor:not-allowed;}
.model-section{display:none;align-items:center;gap:15px;}
.chat-container{flex:1;display:flex;flex-direction:row;background:#1e1e1e;overflow:hidden;}
.messages-container{flex:1;display:flex;flex-direction:column;overflow:hidden;}
.messages{flex:1;overflow-y:auto;padding:20px;}
.message{margin-bottom:20px;padding:15px;border-radius:8px;max-width:85%;white-space:pre-wrap;word-wrap:break-word;}
.message.user{background:#007acc;color:#ffffff;margin-left:auto;}
.message.assistant{background:#2d2d30;border:1px solid #3e3e42;margin-right:auto;}
.message.system{background:#1e3a8a;color:#ffffff;margin:0 auto;text-align:center;max-width:60%;font-style:italic;}
.message ul{margin:10px 0;padding-left:20px;}
.message ol{margin:10px 0;padding-left:20px;}
.message li{margin:5px 0;line-height:1.5;}
.message h1,.message h2,.message h3,.message h4,.message h5,.message h6{margin:15px 0 10px 0;font-weight:bold;color:#ffffff;}
.message h1{font-size:1.5em;}
.message h2{font-size:1.3em;}
.message h3{font-size:1.1em;}
.message strong{font-weight:bold;color:#ffffff;}
.message em{font-style:italic;}
.message p{margin:10px 0;}
.code-block{background:#0d1117;border:1px solid #30363d;border-radius:6px;margin:15px 0;overflow:hidden;}
.code-header{background:#21262d;border-bottom:1px solid #30363d;padding:10px 15px;display:flex;justify-content:space-between;align-items:center;font-size:13px;}
.code-lang{color:#8b949e;font-weight:500;}
.code-actions{display:flex;gap:8px;}
.code-btn{background:transparent;border:1px solid #30363d;color:#8b949e;padding:4px 8px;font-size:12px;border-radius:4px;}
.code-btn:hover{background:#30363d;color:#ffffff;}
.code-content{background:#0d1117;padding:0;margin:0;overflow-x:auto;}
.code-content pre{margin:0;padding:15px;font-family:'SF Mono',Monaco,'Cascadia Code','Roboto Mono',Consolas,monospace;font-size:14px;line-height:1.4;color:#e6edf3;white-space:pre;overflow-x:auto;}
.input-area{background:#2d2d30;border-top:1px solid #3e3e42;padding:15px 20px;display:flex;gap:10px;align-items:flex-end;}
.message-input{flex:1;background:#1e1e1e;border:1px solid #3e3e42;color:#cccccc;padding:12px 15px;border-radius:6px;resize:none;min-height:24px;max-height:120px;font-family:inherit;font-size:14px;line-height:1.4;}
.message-input:focus{outline:none;border-color:#007acc;}
.send-btn{background:#007acc;border:none;color:#ffffff;padding:12px 20px;border-radius:6px;font-weight:500;}
.send-btn:hover:not(:disabled){background:#005a9e;}
.send-btn:disabled{background:#4a4a4a;}
.loading{display:flex;align-items:center;gap:8px;color:#8b949e;}
.spinner{width:16px;height:16px;border:2px solid #3e3e42;border-top:2px solid #007acc;border-radius:50%;animation:spin 1s linear infinite;}
@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
::-webkit-scrollbar{width:12px;}
::-webkit-scrollbar-track{background:#1e1e1e;}
::-webkit-scrollbar-thumb{background:#4a4a4a;border-radius:6px;}
::-webkit-scrollbar-thumb:hover{background:#5a5a5a;}
.chat-history{width:200px;background:#2d2d30;border-left:1px solid #3e3e42;display:flex;flex-direction:column;transition:width .2s;overflow:hidden;}
.chat-history.collapsed{width:40px;}
.chat-history-header{padding:10px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #3e3e42;}
.chat-list{flex:1;overflow-y:auto;}
.chat-item{padding:8px 10px;border-radius:4px;margin:4px;cursor:pointer;background:#3c3c3c;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.chat-item.active{background:#007acc;color:#ffffff;}
.chat-btns{display:flex;flex-direction:column;gap:5px;margin:8px;}
.toggle-history{background:#007acc;color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;cursor:pointer;}
@media(max-width:768px){.header{flex-direction:column;gap:10px;}.connection-group,.model-section{width:100%;justify-content:center;}.message{max-width:95%;}}
</style>
</head>
<body>
<div class="header">
  <div class="title">LM Studio WebChat</div>
  <div class="connection-group">
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    <input type="text" id="serverIp" value="127.0.0.1" placeholder="IP" style="width:150px;">
    <input type="text" id="serverPort" value="1234" placeholder="Port" style="width:80px;">
    <button id="connectBtn">Connect</button>
  </div>
  <div class="model-section" id="modelSection">
    <select id="modelSelect" style="min-width:200px;">
      <option value="">Select model...</option>
    </select>
    <button id="loadModelBtn" disabled>Load</button>
  </div>
</div>

<div class="chat-container">
  <div class="messages-container">
    <div class="messages" id="messages">
      <div class="message system">
        <div>Welcome to LM Studio WebChat! Connect to your server and select a model to start.</div>
      </div>
    </div>
    <div class="input-area">
      <textarea id="messageInput" class="message-input" placeholder="Type your message here..." rows="1"></textarea>
      <button id="sendBtn" class="send-btn" disabled>Send</button>
    </div>
  </div>

  <div class="chat-history" id="chatHistory">
    <div class="chat-history-header">
      <span id="historyTitle">Chats</span>
      <button class="toggle-history" id="toggleHistoryBtn" title="Zwiń">&#x276E;</button>
    </div>
    <div class="chat-list" id="chatList"></div>
    <div class="chat-btns">
      <button id="newChatBtn">New Chat</button>
      <button id="deleteChatBtn">Delete Chat</button>
    </div>
  </div>
</div>

<script>
class DB {
  constructor(name='ChatDB', version=1){
    this.name = name;
    this.version = version;
    this.db = null;
  }

  open(){
    return new Promise((resolve, reject) => {
      if(this.db) return resolve(this.db);
      const req = indexedDB.open(this.name, this.version);
      req.onupgradeneeded = (evt) => {
        const db = evt.target.result;
        if(!db.objectStoreNames.contains('chats')){
          db.createObjectStore('chats', { keyPath: 'id' });
        }
      };
      req.onsuccess = (evt) => {
        this.db = evt.target.result;
        resolve(this.db);
      };
      req.onerror = (evt) => reject(evt.target.error);
    });
  }

  putChat(chatObj){
    return this.open().then(db=>{
      return new Promise((res, rej)=>{
        const tx = db.transaction('chats','readwrite');
        const store = tx.objectStore('chats');
        const r = store.put(chatObj);
        r.onsuccess = ()=>res(r.result);
        r.onerror = (e)=>rej(e.target.error);
      });
    });
  }

  deleteChat(id){
    return this.open().then(db=>{
      return new Promise((res, rej)=>{
        const tx = db.transaction('chats','readwrite');
        const store = tx.objectStore('chats');
        const r = store.delete(id);
        r.onsuccess = ()=>res();
        r.onerror = (e)=>rej(e.target.error);
      });
    });
  }

  getAllChats(){
    return this.open().then(db=>{
      return new Promise((res, rej)=>{
        const tx = db.transaction('chats','readonly');
        const store = tx.objectStore('chats');
        const r = store.getAll();
        r.onsuccess = ()=>res(r.result || []);
        r.onerror = (e)=>rej(e.target.error);
      });
    });
  }
}

class LMStudioChat {
  constructor(){
    this.db = new DB();
    this.initEls();
    this.initState();
    this.bindEvents();
    this.loadSettings();
    this.loadChatsFromDB();
  }

  initEls(){
    this.serverIp = document.getElementById('serverIp');
    this.serverPort = document.getElementById('serverPort');
    this.connectBtn = document.getElementById('connectBtn');
    this.statusDot = document.getElementById('statusDot');
    this.statusText = document.getElementById('statusText');

    this.modelSection = document.getElementById('modelSection');
    this.modelSelect = document.getElementById('modelSelect');
    this.loadModelBtn = document.getElementById('loadModelBtn');

    this.messages = document.getElementById('messages');
    this.messageInput = document.getElementById('messageInput');
    this.sendBtn = document.getElementById('sendBtn');

    this.chatHistory = document.getElementById('chatHistory');
    this.historyTitle = document.getElementById('historyTitle');
    this.chatList = document.getElementById('chatList');
    this.newChatBtn = document.getElementById('newChatBtn');
    this.deleteChatBtn = document.getElementById('deleteChatBtn');
    this.toggleHistoryBtn = document.getElementById('toggleHistoryBtn');
  }

  initState(){
    this.isConnected = false;
    this.isGenerating = false;
    this.currentModel = null;
    this.controller = null;

    this.chats = {};
    this.currentChatId = null;
    this.chatCounter = 0;
    this.historyCollapsed = false;
  }

  bindEvents(){
    this.connectBtn.addEventListener('click', ()=>this.connect());
    this.modelSelect.addEventListener('change', ()=>this.onModelChange());
    this.loadModelBtn.addEventListener('click', ()=>this.loadModel());

    this.sendBtn.addEventListener('click', ()=>this.sendMessage());
    this.messageInput.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); this.sendMessage(); }
    });
    this.messageInput.addEventListener('input', ()=>{ this.adjustTextareaHeight(); this.updateSendButton(); });

    this.newChatBtn.addEventListener('click', ()=>this.createNewChat());
    this.deleteChatBtn.addEventListener('click', ()=>this.deleteCurrentChat());
    this.toggleHistoryBtn.addEventListener('click', ()=>this.toggleHistory());
  }

  loadSettings(){
    try{
      const saved = localStorage.getItem('lmstudio-settings');
      if(saved){
        const s = JSON.parse(saved);
        this.serverIp.value = s.ip || '127.0.0.1';
        this.serverPort.value = s.port || '1234';
      }
    }catch(e){}
  }
  saveSettings(){
    try{ localStorage.setItem('lmstudio-settings', JSON.stringify({ ip: this.serverIp.value, port: this.serverPort.value })); }catch(e){}
  }

  async loadChatsFromDB(){
    try{
      const saved = await this.db.getAllChats();
      if(saved && saved.length){
        saved.sort((a,b)=> (a.updatedAt||0) - (b.updatedAt||0));
        saved.forEach(c=>{
          this.chats[c.id] = c;
          this.chatCounter = Math.max(this.chatCounter, this.extractCounterFromTitle(c.title) || 0);
        });
        const ids = Object.keys(this.chats);
        if(ids.length){
          this.currentChatId = ids[ids.length-1];
          this.renderChatHistory();
          this.loadChatToUI(this.currentChatId);
          return;
        }
      }
      this.createNewChat(true);
    }catch(e){
      console.error('DB load error', e);
      this.createNewChat(true);
    }
  }

  extractCounterFromTitle(title){
    if(!title) return 0;
    const m = title.match(/Chat\s+(\d+)/);
    return m ? parseInt(m[1],10) : 0;
  }

  async persistChat(chatObj){
    try{
      chatObj.updatedAt = Date.now();
      await this.db.putChat(chatObj);
    }catch(e){
      console.error('Persist chat error', e);
    }
  }

  async removeChatFromDB(id){
    try{
      await this.db.deleteChat(id);
    }catch(e){
      console.error('Delete chat from DB error', e);
    }
  }

  getServerUrl(){ return `http://${this.serverIp.value}:${this.serverPort.value}`; }

  async connect(){
    this.connectBtn.disabled = true;
    this.connectBtn.textContent = 'Connecting...';
    try{
      const r = await fetch(`${this.getServerUrl()}/v1/models`);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      this.setConnectionStatus(true);
      this.addMessage('system','Connected to LM Studio server successfully!');
      this.modelSection.style.display = 'flex';
      await this.refreshModels();
      this.saveSettings();
    }catch(e){
      this.setConnectionStatus(false);
      this.addMessage('system', `Connection failed: ${e.message}`);
    }finally{
      this.connectBtn.disabled = false;
      this.connectBtn.textContent = 'Connect';
    }
  }

  setConnectionStatus(ok){
    this.isConnected = ok;
    this.statusDot.classList.toggle('connected', ok);
    this.statusText.textContent = ok ? 'Connected' : 'Disconnected';
    this.updateSendButton();
  }

  async refreshModels(){
    try{
      const r = await fetch(`${this.getServerUrl()}/v1/models`);
      const data = await r.json();
      this.modelSelect.innerHTML = '<option value="">Select model...</option>';
      (data.data || []).forEach(m=>{
        const opt = document.createElement('option'); opt.value = m.id; opt.textContent = m.id; this.modelSelect.appendChild(opt);
      });
    }catch(e){
      this.addMessage('system', `Failed to load models: ${e.message}`);
    }
  }

  onModelChange(){ this.loadModelBtn.disabled = !this.modelSelect.value; }

  async loadModel(){
    const modelId = this.modelSelect.value;
    if(!modelId) return;
    this.loadModelBtn.disabled = true; this.loadModelBtn.textContent = 'Loading...';
    try{
      const r = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ model: modelId, messages:[{role:'user',content:'test'}], max_tokens:1 })
      });
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      this.currentModel = modelId;
      this.addMessage('system', `Model "${modelId}" loaded successfully!`);
      this.updateSendButton();
    }catch(e){
      this.addMessage('system', `Failed to load model: ${e.message}`);
    }finally{
      this.loadModelBtn.disabled = false; this.loadModelBtn.textContent = 'Load';
    }
  }

  async createNewChat(silent=false){
    const id = Date.now().toString();
    this.chatCounter += 1;
    const title = `Chat ${this.chatCounter}`;
    const chatObj = { id, title, messages: [], updatedAt: Date.now() };
    this.chats[id] = chatObj;
    this.currentChatId = id;
    this.messages.innerHTML = '';
    if(!silent) this.addMessage('system', `Nowy czat: ${title}`);
    await this.persistChat(chatObj);
    this.renderChatHistory();
  }

  async deleteCurrentChat(){
    if(!this.currentChatId) return;
    const id = this.currentChatId;
    delete this.chats[id];
    await this.removeChatFromDB(id);
    const ids = Object.keys(this.chats);
    this.currentChatId = ids.length ? ids[ids.length-1] : null;
    this.messages.innerHTML = '';
    if(this.currentChatId){
      this.loadChatToUI(this.currentChatId);
    } else {
      this.addMessage('system','Brak czatu. Użyj "New Chat", aby rozpocząć.');
    }
    this.renderChatHistory();
  }

  loadChatToUI(chatId){
    if(!this.chats[chatId]) return;
    this.currentChatId = chatId;
    this.messages.innerHTML = '';
    (this.chats[chatId].messages || []).forEach(m => this.addMessage(m.role, m.content));
    this.renderChatHistory();
  }

  loadChat(chatId){
    this.loadChatToUI(chatId);
  }

  async saveChatMessage(role, content){
    if(!this.currentChatId) await this.createNewChat();
    const obj = this.chats[this.currentChatId];
    obj.messages.push({ role, content });
    obj.updatedAt = Date.now();
    if(role === 'user' && content){
      const title = content.trim().split('\n')[0].slice(0,60);
      if(title) obj.title = title;
    }
    this.chats[this.currentChatId] = obj;
    await this.persistChat(obj);
    this.renderChatHistory();
  }

  renderChatHistory(){
    this.chatList.innerHTML = '';
    const ids = Object.keys(this.chats);
    ids.forEach(id=>{
      const item = document.createElement('div');
      item.className = 'chat-item' + (id === this.currentChatId ? ' active' : '');
      item.textContent = this.chats[id].title || ('Chat ' + id);
      item.title = this.chats[id].title || id;
      item.addEventListener('click', ()=> this.loadChat(id));
      this.chatList.appendChild(item);
    });
  }

  toggleHistory(){
    this.historyCollapsed = !this.historyCollapsed;
    this.chatHistory.classList.toggle('collapsed', this.historyCollapsed);
    this.toggleHistoryBtn.innerHTML = this.historyCollapsed ? '&#x276F;' : '&#x276E;';
    this.toggleHistoryBtn.title = this.historyCollapsed ? 'Rozwiń' : 'Zwiń';
    this.historyTitle.style.display = this.historyCollapsed ? 'none' : 'inline';
  }

  // Poprawiona metoda formatowania tekstu
  formatContent(content) {
    // Najpierw obsługuj bloki kodu
    let formatted = this.processCodeBlocks(content);
    
    // Jeśli nie ma bloków kodu, zastosuj podstawowe formatowanie markdown
    if (!content.includes('```')) {
      formatted = this.processBasicMarkdown(content);
    }
    
    return formatted;
  }

  processBasicMarkdown(content) {
    let html = content;
    
    // Escape HTML aby zapobiec XSS
    html = html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    
    // Nagłówki
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
    
    // Pogrubienie i kursywa
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Listy punktowane
    html = html.replace(/^[\s]*[-*+]\s+(.+)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Listy numerowane
    html = html.replace(/^[\s]*\d+\.\s+(.+)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/s, '<ol>$1</ol>');
    
    // Podwójne znaki nowej linii jako akapity
    html = html.replace(/\n\n/g, '</p><p>');
    html = '<p>' + html + '</p>';
    
    // Pojedyncze znaki nowej linii jako <br>
    html = html.replace(/\n/g, '<br>');
    
    return html;
  }

  // Poprawiona metoda addMessage
  addMessage(role, content){
    const div = document.createElement('div');
    div.className = `message ${role}`;
    
    if(role === 'assistant' && (content.includes('```') || content.includes('**') || content.includes('# ') || content.includes('- ') || content.includes('* '))){
      div.innerHTML = this.formatContent(content);
    } else {
      // Dla prostego tekstu zachowaj znaki nowej linii używając CSS white-space: pre-wrap
      div.textContent = content;
    }
    
    this.messages.appendChild(div);
    this.messages.scrollTop = this.messages.scrollHeight;
  }

  processCodeBlocks(content){
    return content.replace(/```(\w+)?\n?([\s\S]*?)```/g,(m,lang,code)=>{
      const language = (lang||'text').toUpperCase();
      const clean = (code||'').trim();
      const codeId = 'code_' + Math.random().toString(36).slice(2,9);
      return `
        <div class="code-block">
          <div class="code-header">
            <span class="code-lang">${language}</span>
            <div class="code-actions">
              <button class="code-btn" onclick="copyCode('${codeId}')">Copy</button>
            </div>
          </div>
          <div class="code-content"><pre id="${codeId}">${this.escapeHtml(clean)}</pre></div>
        </div>`;
    });
  }

  escapeHtml(text){
    const d = document.createElement('div'); d.textContent = text; return d.innerHTML;
  }

  adjustTextareaHeight(){
    this.messageInput.style.height = 'auto';
    this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
  }

  updateSendButton(){
    if(this.isGenerating){
      this.sendBtn.disabled = false;
      this.sendBtn.textContent = 'Cancel';
    } else {
      const canSend = this.isConnected && this.currentModel && this.messageInput.value.trim();
      this.sendBtn.disabled = !canSend;
      this.sendBtn.textContent = 'Send';
    }
  }

  buildConversationForRequest(){
    const hist = (this.chats[this.currentChatId] && this.chats[this.currentChatId].messages) || [];
    return hist.map(m => ({ role: m.role, content: m.content }));
  }

  async sendMessage(){
    if(this.isGenerating){
      if(this.controller) this.controller.abort();
      this.isGenerating = false;
      this.updateSendButton();
      document.getElementById('loading-message')?.remove();
      return;
    }

    const content = this.messageInput.value.trim();
    if(!content || !this.isConnected || !this.currentModel) return;

    if(!this.currentChatId) await this.createNewChat();

    this.addMessage('user', content);
    await this.saveChatMessage('user', content);

    this.messageInput.value = '';
    this.adjustTextareaHeight();

    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message assistant';
    loadingDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Generating response...</div>';
    loadingDiv.id = 'loading-message';
    this.messages.appendChild(loadingDiv);
    this.messages.scrollTop = this.messages.scrollHeight;

    this.isGenerating = true;
    this.updateSendButton();

    let assistantMessage = '';
    let messageElement = null;
    this.controller = new AbortController();

    try{
      const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        signal: this.controller.signal,
        body: JSON.stringify({
          model: this.currentModel,
          messages: this.buildConversationForRequest(),
          stream: true,
          max_tokens: -1
        })
      });

      if(!response.ok) throw new Error(`HTTP ${response.status}`);

      document.getElementById('loading-message')?.remove();

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while(true){
        const { done, value } = await reader.read();
        if(done) break;
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for(const line of lines){
          if(!line || !line.startsWith('data: ')) continue;
          const data = line.slice(6);
          if(data === '[DONE]') break;
          try{
            const parsed = JSON.parse(data);
            const delta = parsed.choices?.[0]?.delta?.content;
            if(delta){
              assistantMessage += delta;
              if(!messageElement){
                messageElement = document.createElement('div');
                messageElement.className = 'message assistant';
                this.messages.appendChild(messageElement);
              }
              
              // Użyj nowej metody formatowania
              if(assistantMessage.includes('```') || assistantMessage.includes('**') || assistantMessage.includes('# ') || assistantMessage.includes('- ') || assistantMessage.includes('* ')){
                messageElement.innerHTML = this.formatContent(assistantMessage);
              } else {
                messageElement.textContent = assistantMessage;
              }
              this.messages.scrollTop = this.messages.scrollHeight;
            }
          }catch(_e){}
        }
      }

      if(assistantMessage){
        await this.saveChatMessage('assistant', assistantMessage);
      }

    }catch(e){
      document.getElementById('loading-message')?.remove();
      if(e.name !== 'AbortError') this.addMessage('system', `Error: ${e.message}`);
    }finally{
      this.isGenerating = false;
      this.updateSendButton();
      this.controller = null;
    }
  }
}

// copy code helper
async function copyCode(codeId){
  const el = document.getElementById(codeId);
  if(!el) return;
  try{
    await navigator.clipboard.writeText(el.textContent);
    const btn = el.closest('.code-block').querySelector('.code-btn');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(()=> btn.textContent = orig, 2000);
  }catch(e){ console.error('copy failed', e); }
}

document.addEventListener('DOMContentLoaded', ()=>{ new LMStudioChat(); });
</script>
</body>
</html>