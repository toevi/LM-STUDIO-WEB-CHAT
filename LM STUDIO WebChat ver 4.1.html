<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LM Studio WebChat v2</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .version-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .connection-panel {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .model-panel, .history-panel {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: white;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4444;
            transition: background-color 0.3s ease;
        }

        .status-dot.connected {
            background-color: #44ff44;
            box-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group label {
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .input-group input, .input-group select {
            padding: 0.4rem 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .input-group input {
            width: 120px;
        }

        .model-select, .conversation-select {
            min-width: 180px;
        }

        .model-select option, .conversation-select option {
            background: #333;
            color: white;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4444, #cc3333);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
            color: #333;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .model-status {
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .model-status.loaded {
            background: rgba(68, 255, 68, 0.2);
            color: #44ff44;
            border: 1px solid rgba(68, 255, 68, 0.3);
        }

        .model-status.unloaded {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        .model-status.loading {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .loaded-models-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 0.5rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
        }

        .panel-header:hover {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            margin: -0.2rem -0.4rem 0.3rem -0.4rem;
        }

        .panel-status-text {
            font-size: 0.8rem;
            opacity: 0.8;
            font-style: italic;
            margin-left: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .panel-status-text:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .panel-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .panel-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .panel-toggle.collapsed::after {
            content: '▼';
            margin-left: 0.3rem;
        }

        .panel-toggle.expanded::after {
            content: '▲';
            margin-left: 0.3rem;
        }

        .loaded-models-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .loaded-models-list.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .loaded-models-list.expanded {
            max-height: 500px;
            opacity: 1;
        }

        .compact-panel {
            padding: 0.4rem 0.8rem;
            margin-top: 0.3rem;
        }

        .compact-panel .panel-header {
            margin-bottom: 0.2rem;
        }

        .compact-panel .panel-toggle {
            padding: 0.1rem 0.4rem;
            font-size: 0.7rem;
        }

        .history-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .history-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
            border: none;
        }

        .history-content.expanded {
            max-height: 200px;
            opacity: 1;
        }

        .history-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .history-panel.compact {
            padding: 0.4rem 0.8rem;
        }

        .loaded-model-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 0.85rem;
        }

        .loaded-model-info {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .loaded-model-name {
            font-weight: 500;
            color: #44ff44;
        }

        .loaded-model-status {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .loaded-model-actions {
            display: flex;
            gap: 0.3rem;
        }

        .model-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }

        .model-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .model-action-btn.danger {
            background: rgba(255, 68, 68, 0.3);
            border-color: rgba(255, 68, 68, 0.5);
        }

        .model-action-btn.danger:hover {
            background: rgba(255, 68, 68, 0.5);
        }

        .no-models-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
            padding: 1rem;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            margin: 1rem;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .chat-header {
            background: rgba(102, 126, 234, 0.1);
            padding: 0.5rem 1rem;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #666;
        }

        .conversation-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #F5F5DC;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            background: linear-gradient(135deg, #e3f2fd, #f0f4ff);
            color: #1a1a1a;
            margin-right: auto;
            border-bottom-left-radius: 4px;
            border: 1px solid #e0e7ff;
        }

        .message.system {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            margin: 0 auto;
            text-align: center;
            font-style: italic;
            max-width: 60%;
        }

        .message-content {
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .message-timestamp {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-top: 0.5rem;
        }

        .message-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: none;
            gap: 0.25rem;
        }

        .message:hover .message-actions {
            display: flex;
        }

        .action-btn {
            background: rgba(0,0,0,0.15);
            border: none;
            border-radius: 4px;
            color: #333;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .action-btn:hover {
            background: rgba(0,0,0,0.25);
            transform: scale(1.1);
        }

        /* Code compact display styles */
        .code-compact-container {
            background-color: #0d0d0d;   /* czarne tło */
            color: #f8f8f2;              /* jasny tekst */
            padding: 12px;
            border-radius: 8px;
            font-family: "Fira Code", "Consolas", monospace;
            overflow-x: auto;
            position: relative; /* żeby przycisk można było ustawić w rogu */
        }

        .code-compact-header {
            background: #e9ecef;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border-bottom: 1px solid #dee2e6;
        }

        .code-icon {
            font-size: 1.2rem;
        }

        .code-info {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
        }

        .code-copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #222;     /* ciemny szary */
            color: #fff;                /* biały tekst */
            border: 1px solid #444;     /* delikatna ramka */
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
            z-index: 10;                /* zawsze nad kodem */
        }

        .code-copy-btn:hover {
            background: #444;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .code-copy-btn.copied {
            background-color: #28a745; /* zielony jak GitHub */
            border-color: #28a745;
			
        }

        .code-original {
            position: absolute;
            left: -9999px;
            top: -9999px;
            white-space: pre;
            font-family: monospace;
            opacity: 0;
            pointer-events: none;
        }

        /* Inline code */
        .message-content code:not(.code-compact-container code) {
            background: rgba(0,0,0,0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.9em;
            color: #d63384;
            white-space: pre;
        }

        .message.assistant .message-content code:not(.code-compact-container code) {
            background: rgba(13, 110, 253, 0.1);
            color: #0d6efd;
        }

        .input-area {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-top: 1px solid rgba(0,0,0,0.1);
        }

        .message-input {
            flex: 1;
            resize: none;
            border: 2px solid #ddd;
            border-radius: 25px;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            font-family: inherit;
            background: white;
            transition: all 0.2s ease;
            max-height: 120px;
            min-height: 50px;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .send-btn, .stop-chat-btn {
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s ease;
            color: white;
        }

        .send-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .send-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .stop-chat-btn {
            background: linear-gradient(45deg, #ff4444, #cc3333);
        }

        .stop-chat-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.4);
        }

        .send-btn:disabled, .stop-chat-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .loading-dots {
            display: inline-flex;
            gap: 0.2rem;
        }

        .loading-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #667eea;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        @media (max-width: 768px) {
            .connection-panel, .model-panel, .history-panel {
                width: 100%;
                justify-content: center;
            }
            
            .input-group {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .input-group input, .input-group select {
                width: 150px;
            }
            
            .message {
                max-width: 95%;
            }
            
            .header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }

            .panel-header {
                flex-direction: column;
                gap: 0.5rem;
                align-items: stretch;
            }

            .panel-toggle {
                align-self: center;
            }

            .loaded-models-panel, .history-panel {
                margin-top: 0.3rem;
            }
        	         	    
        }
</style>
</head>
<body>
    <div class="header">
        <div class="title">
            🤖 LM Studio WebChat 
            <span class="version-badge">v2.0</span>
        </div>
        <div class="connection-panel">
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Rozłączony</span>
            </div>
            
            <div class="input-group">
                <label>IP:</label>
                <input type="text" id="serverIp" value="127.0.0.1" placeholder="127.0.0.1">
            </div>
            
            <div class="input-group">
                <label>Port:</label>
                <input type="text" id="serverPort" value="1234" placeholder="1234">
            </div>
            
            <button class="btn btn-primary" id="testConnectionBtn">Test</button>
        </div>
        
        <div class="model-panel" id="modelPanel" style="display: none;">
            <div class="input-group">
                <label>Model:</label>
                <select class="model-select" id="modelSelect">
                    <option value="">Wybierz model...</option>
                </select>
            </div>
            
            <button class="btn btn-primary" id="loadModelBtn" disabled>Załaduj</button>
            <button class="btn btn-secondary" id="refreshModelsBtn">Odśwież</button>
            
            <div class="connection-status">
                <span>Status:</span>
                <div class="model-status unloaded" id="modelStatus">Brak modelu</div>
            </div>
        </div>

        <div class="loaded-models-panel" id="loadedModelsPanel" style="display: none;">
            <div class="panel-header" id="loadedModelsHeader">
                <span>Załadowane modele: <span class="panel-status-text">Zwiń</span></span>
                <button class="btn btn-secondary" id="refreshLoadedModelsBtn">🔄</button>
            </div>
            <div class="loaded-models-list expanded" id="loadedModelsList">
                <!-- Tu będą wyświetlane załadowane modele -->
            </div>
        </div>

        <div class="history-panel" id="historyPanel" style="display: none;">
            <div class="panel-header" id="historyHeader">
                <span>Historia konwersacji: <span class="panel-status-text">Zwiń</span></span>
            </div>
            <div class="history-content expanded" id="historyContent">
                <div class="input-group">
                    <label>Konwersacja:</label>
                    <select class="conversation-select" id="conversationSelect">
                        <option value="new">Nowa konwersacja</option>
                    </select>
                </div>
                
                <button class="btn btn-primary" id="newConversationBtn">Nowa</button>
                <button class="btn btn-secondary" id="loadHistoryBtn">Załaduj historię</button>
                <button class="btn btn-warning" id="clearCurrentBtn">Wyczyść obecną</button>
                <button class="btn btn-danger" id="deleteConversationBtn" disabled>Usuń konwersację</button>
            </div>
        </div>
    </div>

    <div class="chat-container">
        <div class="chat-header">
            <div class="conversation-info">
                <span id="conversationTitle">Konwersacja: Nowa</span>
                <span id="messageCount">Wiadomości: 0</span>
                <span id="contextInfo">Kontekst: Pusty</span>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                <div class="message-content">Witaj w LM Studio WebChat v2! Skonfiguruj połączenie z serwerem i wybierz model. Nowa wersja automatycznie zarządza historią konwersacji.</div>
            </div>
        </div>
        
        <div class="input-area">
            <textarea 
                class="message-input" 
                id="messageInput" 
                placeholder="Wpisz swoją wiadomość tutaj..."
                rows="1"></textarea>
            <button class="send-btn" id="sendBtn" title="Wyślij wiadomość">
                ➤
            </button>
            <button class="stop-chat-btn" id="stopChatBtn" title="Stop Chat" disabled>
                ⏹
            </button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/php.min.js"></script>

    <script>
        class LMStudioChatV2 {
            constructor() {
                this.initializeElements();
                this.initializeState();
                this.initializeEventListeners();
                this.loadSettings();
            }

            initializeElements() {
                this.serverIp = document.getElementById('serverIp');
                this.serverPort = document.getElementById('serverPort');
                this.testConnectionBtn = document.getElementById('testConnectionBtn');
                this.statusDot = document.getElementById('statusDot');
                this.statusText = document.getElementById('statusText');
                this.modelPanel = document.getElementById('modelPanel');
                this.modelSelect = document.getElementById('modelSelect');
                this.loadModelBtn = document.getElementById('loadModelBtn');
                this.refreshModelsBtn = document.getElementById('refreshModelsBtn');
                this.modelStatus = document.getElementById('modelStatus');
                this.loadedModelsPanel = document.getElementById('loadedModelsPanel');
                this.loadedModelsList = document.getElementById('loadedModelsList');
                this.refreshLoadedModelsBtn = document.getElementById('refreshLoadedModelsBtn');
                this.loadedModelsHeader = document.getElementById('loadedModelsPanel').querySelector('.panel-status-text');
                this.historyPanel = document.getElementById('historyPanel');
                this.historyHeader = document.getElementById('historyPanel').querySelector('.panel-status-text');
                this.historyContent = document.getElementById('historyContent');
                this.conversationSelect = document.getElementById('conversationSelect');
                this.newConversationBtn = document.getElementById('newConversationBtn');
                this.loadHistoryBtn = document.getElementById('loadHistoryBtn');
                this.clearCurrentBtn = document.getElementById('clearCurrentBtn');
                this.deleteConversationBtn = document.getElementById('deleteConversationBtn');
                this.chatMessages = document.getElementById('chatMessages');
                this.messageInput = document.getElementById('messageInput');
                this.sendBtn = document.getElementById('sendBtn');
                this.stopChatBtn = document.getElementById('stopChatBtn');
                this.conversationTitle = document.getElementById('conversationTitle');
                this.messageCount = document.getElementById('messageCount');
                this.contextInfo = document.getElementById('contextInfo');
                
                // Debugowanie - sprawdzamy czy elementy zostały znalezione
                console.log('Elementy załadowane:');
                console.log('loadedModelsHeader (tekst statusu):', this.loadedModelsHeader);
                console.log('historyHeader (tekst statusu):', this.historyHeader);
            }

            initializeState() {
                this.isConnected = false;
                this.isGenerating = false;
                this.currentController = null;
                this.availableModels = [];
                this.currentModel = null;
                this.loadedModels = new Set(); // Śledzimy załadowane modele
                this.currentConversationId = 'new';
                this.conversationHistory = [];
                this.localStorageAvailable = this.checkLocalStorage();
                
                try {
                    if (this.localStorageAvailable) {
                        this.conversations = JSON.parse(localStorage.getItem('lmstudio-conversations') || '{}');
                    } else {
                        console.warn('localStorage not available, conversations will not be saved');
                        this.conversations = {};
                    }
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.conversations = {};
                }
            }

            checkLocalStorage() {
                try {
                    const test = 'localStorage-test';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            initializeEventListeners() {
                this.testConnectionBtn.addEventListener('click', () => this.testConnection());
                this.loadModelBtn.addEventListener('click', () => this.loadModel());
                this.refreshModelsBtn.addEventListener('click', () => this.loadAvailableModels());
                this.refreshLoadedModelsBtn.addEventListener('click', () => this.refreshLoadedModels());
                
                // Event listenery dla zwijania/rozwijania paneli
                if (this.loadedModelsHeader) {
                    this.loadedModelsHeader.addEventListener('click', () => {
                        console.log('Kliknięto tekst statusu loadedModelsHeader');
                        this.toggleLoadedModelsPanel();
                    });
                }
                
                this.modelSelect.addEventListener('change', () => this.onModelSelectChange());
                this.newConversationBtn.addEventListener('click', () => this.createNewConversation());
                this.loadHistoryBtn.addEventListener('click', () => this.loadConversationHistory());
                this.clearCurrentBtn.addEventListener('click', () => this.clearCurrentConversation());
                this.deleteConversationBtn.addEventListener('click', () => this.deleteConversation());
                
                // Event listenery dla historii
                if (this.historyHeader) {
                    this.historyHeader.addEventListener('click', () => {
                        console.log('Kliknięto tekst statusu historyHeader');
                        this.toggleHistoryPanel();
                    });
                }
                
                this.conversationSelect.addEventListener('change', () => this.onConversationSelectChange());
                this.sendBtn.addEventListener('click', () => this.sendMessage());
                this.stopChatBtn.addEventListener('click', () => this.stopGeneration());
                this.messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                        this.refreshLoadedModels();
                    }
                });
                this.messageInput.addEventListener('input', () => {
                    this.adjustTextareaHeight();
                    this.updateSendButtonState();
                });
                this.serverIp.addEventListener('change', () => this.saveSettings());
                this.serverPort.addEventListener('change', () => this.saveSettings());
            }

            saveSettings() {
                if (!this.localStorageAvailable) return;
                
                try {
                    const settings = {
                        serverIp: this.serverIp.value,
                        serverPort: this.serverPort.value,
                        selectedModel: this.modelSelect.value,
                        currentConversation: this.currentConversationId
                    };
                    localStorage.setItem('lmstudio-settings', JSON.stringify(settings));
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }

            loadSettings() {
                try {
                    if (this.localStorageAvailable) {
                        const saved = localStorage.getItem('lmstudio-settings');
                        if (saved) {
                            const settings = JSON.parse(saved);
                            this.serverIp.value = settings.serverIp || '127.0.0.1';
                            this.serverPort.value = settings.serverPort || '1234';
                            this.savedModel = settings.selectedModel;
                            this.savedConversation = settings.currentConversation || 'new';
                        } else {
                            this.setDefaultSettings();
                        }
                    } else {
                        this.setDefaultSettings();
                    }
                } catch (error) {
                    console.error('Error loading settings:', error);
                    this.setDefaultSettings();
                }
                this.populateConversationSelect();
            }

            setDefaultSettings() {
                this.serverIp.value = '127.0.0.1';
                this.serverPort.value = '1234';
                this.savedConversation = 'new';
            }

            getServerUrl() {
                return `http://${this.serverIp.value}:${this.serverPort.value}`;
            }

            adjustTextareaHeight() {
                this.messageInput.style.height = 'auto';
                this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
            }

            async testConnection() {
                this.testConnectionBtn.disabled = true;
                this.testConnectionBtn.textContent = 'Testowanie...';

                try {
                    const response = await fetch(`${this.getServerUrl()}/v1/models`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (response.ok) {
                        this.setConnectionStatus(true);
                        this.addMessage('system', 'Połączenie z serwerem LM Studio nawiązane pomyślnie!');
                        
                        this.modelPanel.style.display = 'flex';
                        this.historyPanel.style.display = 'flex';
                        await this.loadAvailableModels();
                        await this.checkCurrentModel();
                        // Automatycznie odświeżamy listę po połączeniu
                        await this.refreshLoadedModels();
                        this.loadSavedConversation();
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    this.setConnectionStatus(false);
                    this.modelPanel.style.display = 'none';
                    this.modelPanel.style.display = 'none';
                    this.historyPanel.style.display = 'none';
                    let errorMsg = 'Błąd połączenia';
                    if (error.message.includes('Failed to fetch')) {
                        errorMsg = 'Błąd połączenia z serwerem - sprawdź czy serwer działa';
                    } else {
                        errorMsg = `Błąd połączenia: ${error.message}`;
                    }
                    this.addMessage('system', errorMsg);
                } finally {
                    this.testConnectionBtn.disabled = false;
                    this.testConnectionBtn.textContent = 'Test';
                }
            }

            setConnectionStatus(connected) {
                this.isConnected = connected;
                this.statusDot.classList.toggle('connected', connected);
                this.statusText.textContent = connected ? 'Połączony' : 'Rozłączony';
                
                if (!connected) {
                    this.modelPanel.style.display = 'none';
                    this.loadedModelsPanel.style.display = 'none';
                    this.historyPanel.style.display = 'none';
                    this.updateModelStatus('unloaded', 'Brak połączenia');
                } else {
                    this.loadedModelsPanel.style.display = 'block';
                    this.historyPanel.style.display = 'flex';
                    // Automatycznie odświeżamy listę po połączeniu
                    setTimeout(() => this.refreshLoadedModels(), 1000);
                    // Automatycznie zwijamy panele po połączeniu, żeby oszczędzić miejsce
                    setTimeout(() => {
                        this.collapseLoadedModelsPanel();
                        this.collapseHistoryPanel();
                    }, 1500);
                }
                
                this.updateSendButtonState();
            }

            updateSendButtonState() {
                const canSend = this.isConnected && !this.isGenerating && this.currentModel && this.messageInput.value.trim();
                this.sendBtn.disabled = !canSend;
                this.stopChatBtn.disabled = !this.isGenerating;
            }

            async loadAvailableModels() {
                this.refreshModelsBtn.disabled = true;
                this.refreshModelsBtn.textContent = 'Ładowanie...';

                try {
                    const response = await fetch(`${this.getServerUrl()}/v1/models`);
                    
                    const data = await response.json();
                    this.availableModels = data.data || [];
                    this.populateModelSelect();
                    
                    this.addMessage('system', `Znaleziono ${this.availableModels.length} dostępnych modeli.`);
                    
                    // Automatycznie odświeżamy listę po załadowaniu dostępnych modeli
                    if (this.isConnected) {
                        await this.refreshLoadedModels();
                    }
                } catch (error) {
                    this.addMessage('system', `Błąd ładowania modeli: ${error.message}`);
                } finally {
                    this.refreshModelsBtn.disabled = false;
                    this.refreshModelsBtn.textContent = 'Odśwież';
                }
            }

            populateModelSelect() {
                this.modelSelect.innerHTML = '<option value="">Wybierz model...</option>';
                
                this.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    this.modelSelect.appendChild(option);
                });

                if (this.savedModel && this.availableModels.find(m => m.id === this.savedModel)) {
                    this.modelSelect.value = this.savedModel;
                    this.onModelSelectChange();
                }
            }

            onModelSelectChange() {
                const selectedModel = this.modelSelect.value;
                this.loadModelBtn.disabled = !selectedModel;
                this.saveSettings();
            }

            async checkCurrentModel() {
                try {
                    const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            messages: [{ role: 'user', content: 'test' }],
                            max_tokens: 1,
                            stream: false
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.model) {
                            this.currentModel = data.model;
                            this.loadedModels.add(data.model); // Dodajemy do listy załadowanych
                            this.updateModelStatus('loaded', `Załadowany: ${this.currentModel}`);
                            this.loadModelBtn.disabled = true;

                            if (this.availableModels.find(m => m.id === this.currentModel)) {
                                this.modelSelect.value = this.currentModel;
                            }
                        }
                    } else {
                        this.updateModelStatus('unloaded', 'Brak załadowanego modelu');
                    }
                } catch (error) {
                    this.updateModelStatus('unloaded', 'Błąd sprawdzania modelu');
                }
                
                this.updateSendButtonState();
                // Sprawdzamy tylko nasze załadowane modele
                await this.refreshLoadedModels();
            }

            async loadModel() {
                const selectedModel = this.modelSelect.value;
                if (!selectedModel) return;

                this.loadModelBtn.disabled = true;
                this.loadModelBtn.textContent = 'Ładowanie...';
                this.updateModelStatus('loading', 'Inicjalizacja ładowania modelu...');

                try {
                    this.addMessage('system', `Rozpoczynam ładowanie modelu "${selectedModel}"...`);
                    
                    // Próba załadowania modelu
                    const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: selectedModel,
                            messages: [{ role: 'user', content: 'test' }],
                            max_tokens: 1,
                            stream: false
                        })
                    });

                    if (response.ok) {
                        this.addMessage('system', 'Model zainicjalizowany, sprawdzam gotowość...');
                        
                        // Sprawdzanie czy model rzeczywiście odpowiada
                        await this.waitForModelReady(selectedModel);
                        
                        this.currentModel = selectedModel;
                        this.loadedModels.add(selectedModel); // Dodajemy do listy załadowanych
                        this.updateModelStatus('loaded', `Załadowany: ${selectedModel}`);
                        this.loadModelBtn.disabled = true;
                        this.addMessage('system', `✅ Model "${selectedModel}" został załadowany pomyślnie i jest gotowy do użycia!`);
                        
                        // Automatycznie odświeżamy listę załadowanych modeli
                        await this.refreshLoadedModels();
                    } else {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }
                } catch (error) {
                    this.updateModelStatus('unloaded', 'Błąd ładowania');
                    let errorMsg = 'Błąd ładowania modelu';
                    
                    if (error.message.includes('Failed to fetch')) {
                        errorMsg = '❌ Błąd połączenia z serwerem - sprawdź czy serwer LM Studio działa';
                    } else if (error.message.includes('Ładowanie anulowane')) {
                        errorMsg = '⚠️ Ładowanie modelu zostało anulowane przez użytkownika';
                    } else if (error.message.includes('nie został załadowany w oczekiwanym czasie')) {
                        errorMsg = '⏰ Model nie został załadowany w oczekiwanym czasie (8 minut) - spróbuj ponownie';
                    } else {
                        errorMsg = `❌ Błąd ładowania modelu: ${error.message}`;
                    }
                    
                    this.addMessage('system', errorMsg);
                } finally {
                    this.loadModelBtn.disabled = false;
                    this.loadModelBtn.textContent = 'Załaduj';
                    this.updateSendButtonState();
                }
            }

            async waitForModelReady(modelId, maxAttempts = 60) {
                // Czekamy maksymalnie 8 minut (60 * 8 sekund)
                let attempts = 0;
                let isCancelled = false;
                
                // Dodajemy przycisk anulowania
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Anuluj ładowanie';
                cancelBtn.className = 'cancel-loading-btn';
                cancelBtn.style.cssText = 'background: #ff4444; color: white; border: none; padding: 5px 10px; border-radius: 5px; margin-left: 10px; cursor: pointer;';
                cancelBtn.onclick = () => {
                    isCancelled = true;
                    this.updateModelStatus('unloaded', 'Ładowanie anulowane przez użytkownika');
                    this.loadModelBtn.disabled = false;
                    this.loadModelBtn.textContent = 'Załaduj';
                };
                
                // Dodajemy przycisk do statusu
                const statusContainer = document.querySelector('.model-status');
                if (statusContainer) {
                    statusContainer.appendChild(cancelBtn);
                }
                
                while (attempts < maxAttempts && !isCancelled) {
                    try {
                        // Sprawdzamy czy model odpowiada na proste zapytanie
                        const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: modelId,
                                messages: [{ role: 'user', content: 'test' }],
                                max_tokens: 1,
                                stream: false
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.model && data.choices && data.choices.length > 0) {
                                // Model odpowiada poprawnie - dodatkowa walidacja
                                const validationResponse = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        model: modelId,
                                        messages: [{ role: 'user', content: 'Odpowiedz jednym słowem: OK' }],
                                        max_tokens: 5,
                                        stream: false
                                    })
                                });
                                
                                if (validationResponse.ok) {
                                    const validationData = await validationResponse.json();
                                    if (validationData.choices && validationData.choices[0] && validationData.choices[0].message) {
                                        // Usuwamy przycisk anulowania
                                        if (cancelBtn.parentNode) {
                                            cancelBtn.parentNode.removeChild(cancelBtn);
                                        }
                                        
                                        this.updateModelStatus('loading', `Model gotowy! (${attempts + 1}/${maxAttempts} prób)`);
                                        // Odświeżamy listę załadowanych modeli
                                        await this.refreshLoadedModels();
                                        return true;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        // Ignorujemy błędy podczas sprawdzania - model może jeszcze się ładować
                    }

                    attempts++;
                    
                    // Aktualizujemy status co 8 sekund
                    if (attempts % 8 === 0) {
                        const minutes = Math.floor(attempts / 8);
                        const seconds = (attempts % 8) * 8;
                        this.updateModelStatus('loading', `Ładowanie modelu... (${minutes}:${seconds.toString().padStart(2, '0')})`);
                    }
                    
                    // Czekamy 8 sekund przed kolejną próbą
                    await new Promise(resolve => setTimeout(resolve, 8000));
                }

                // Usuwamy przycisk anulowania
                if (cancelBtn.parentNode) {
                    cancelBtn.parentNode.removeChild(cancelBtn);
                }

                if (isCancelled) {
                    throw new Error('Ładowanie anulowane przez użytkownika');
                }

                throw new Error('Model nie został załadowany w oczekiwanym czasie (8 minut)');
            }

            async refreshLoadedModels() {
                try {
                    // Sprawdzamy tylko modele z naszej listy załadowanych
                    const loadedModels = [];
                    
                    // Sprawdzamy aktualnie załadowany model
                    if (this.currentModel && this.loadedModels.has(this.currentModel)) {
                        try {
                            const testResponse = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    model: this.currentModel,
                                    messages: [{ role: 'user', content: 'test' }],
                                    max_tokens: 1,
                                    stream: false
                                })
                            });

                            if (testResponse.ok) {
                                const testData = await testResponse.json();
                                if (testData.model && testData.choices && testData.choices.length > 0) {
                                    loadedModels.push({
                                        id: this.currentModel,
                                        name: this.currentModel,
                                        status: 'ready',
                                        isCurrent: true
                                    });
                                } else {
                                    // Model nie odpowiada - usuwamy z listy
                                    this.loadedModels.delete(this.currentModel);
                                }
                            } else {
                                // Model nie odpowiada - usuwamy z listy
                                this.loadedModels.delete(this.currentModel);
                            }
                        } catch (error) {
                            // Model nie odpowiada - usuwamy z listy
                            this.loadedModels.delete(this.currentModel);
                            console.log(`Model ${this.currentModel} nie odpowiada:`, error.message);
                        }
                    }

                    // Sprawdzamy inne załadowane modele (maksymalnie 2 dodatkowe)
                    const otherModels = Array.from(this.loadedModels)
                        .filter(modelId => modelId !== this.currentModel)
                        .slice(0, 2);

                    for (const modelId of otherModels) {
                        try {
                            const testResponse = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    model: modelId,
                                    messages: [{ role: 'user', content: 'test' }],
                                    max_tokens: 1,
                                    stream: false
                                })
                            });

                            if (testResponse.ok) {
                                const testData = await testResponse.json();
                                if (testData.model && testData.choices && testData.choices.length > 0) {
                                    loadedModels.push({
                                        id: modelId,
                                        name: modelId,
                                        status: 'ready',
                                        isCurrent: false
                                    });
                                } else {
                                    // Model nie odpowiada - usuwamy z listy
                                    this.loadedModels.delete(modelId);
                                }
                            } else {
                                // Model nie odpowiada - usuwamy z listy
                                this.loadedModels.delete(modelId);
                            }
                        } catch (error) {
                            // Model nie odpowiada - usuwamy z listy
                            this.loadedModels.delete(modelId);
                        }
                    }

                    this.displayLoadedModels(loadedModels);
                } catch (error) {
                    console.error('Błąd odświeżania załadowanych modeli:', error);
                }
            }

            displayLoadedModels(loadedModels) {
                this.loadedModelsList.innerHTML = '';
                
                if (loadedModels.length === 0) {
                    this.loadedModelsList.innerHTML = '<div class="no-models-message">Brak załadowanych modeli</div>';
                    return;
                }

                loadedModels.forEach(model => {
                    const modelItem = document.createElement('div');
                    modelItem.className = 'loaded-model-item';
                    
                    const modelInfo = document.createElement('div');
                    modelInfo.className = 'loaded-model-info';
                    
                    const modelName = document.createElement('div');
                    modelName.className = 'loaded-model-name';
                    modelName.textContent = model.name;
                    if (model.isCurrent) {
                        modelName.textContent += ' (aktywny)';
                        modelName.style.color = '#ffc107';
                    }
                    
                    const modelStatus = document.createElement('div');
                    modelStatus.className = 'loaded-model-status';
                    modelStatus.textContent = `Status: ${model.status}`;
                    
                    modelInfo.appendChild(modelName);
                    modelInfo.appendChild(modelStatus);
                    
                    const modelActions = document.createElement('div');
                    modelActions.className = 'loaded-model-actions';
                    
                    const unloadBtn = document.createElement('button');
                    unloadBtn.className = 'model-action-btn danger';
                    unloadBtn.textContent = 'Wyładuj';
                    unloadBtn.title = 'Wyładuj model';
                    unloadBtn.onclick = () => this.unloadSpecificModel(model.id);
                    
                    const testBtn = document.createElement('button');
                    testBtn.className = 'model-action-btn';
                    testBtn.textContent = 'Test';
                    testBtn.title = 'Przetestuj model';
                    testBtn.onclick = () => this.testSpecificModel(model.id);
                    
                    modelActions.appendChild(testBtn);
                    modelActions.appendChild(unloadBtn);
                    
                    modelItem.appendChild(modelInfo);
                    modelItem.appendChild(modelActions);
                    
                    this.loadedModelsList.appendChild(modelItem);
                });
            }

            async unloadSpecificModel(modelId) {
                if (confirm(`Czy na pewno chcesz wyładować model "${modelId}"?`)) {
                    try {
                        // Próbujemy wyładować model przez wysłanie pustego zapytania
                        // LM Studio może nie mieć dedykowanego endpointu do wyładowywania
                        this.addMessage('system', `Próba wyładowania modelu "${modelId}"...`);
                        
                        // Usuwamy model z listy załadowanych
                        this.loadedModels.delete(modelId);
                        
                        // Jeśli to aktualny model, resetujemy go
                        if (modelId === this.currentModel) {
                            this.currentModel = null;
                            this.updateModelStatus('unloaded', 'Brak modelu');
                            this.loadModelBtn.disabled = false;
                            this.loadModelBtn.textContent = 'Załaduj';
                            this.addMessage('system', `Model "${modelId}" został wyładowany.`);
                        } else {
                            this.addMessage('system', `Model "${modelId}" został oznaczony jako wyładowany.`);
                        }
                        
                        // Odświeżamy listę
                        await this.refreshLoadedModels();
                        this.updateSendButtonState();
                        
                    } catch (error) {
                        this.addMessage('system', `Błąd wyładowywania modelu: ${error.message}`);
                    }
                }
            }

            async testSpecificModel(modelId) {
                try {
                    this.addMessage('system', `Testowanie modelu "${modelId}"...`);
                    
                    const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: modelId,
                            messages: [{ role: 'user', content: 'Odpowiedz jednym słowem: OK' }],
                            max_tokens: 5,
                            stream: false
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.choices && data.choices[0] && data.choices[0].message) {
                            this.addMessage('system', `✅ Model "${modelId}" odpowiada poprawnie: "${data.choices[0].message.content}"`);
                        } else {
                            this.addMessage('system', `⚠️ Model "${modelId}" odpowiada, ale bez treści`);
                        }
                    } else {
                        this.addMessage('system', `❌ Model "${modelId}" nie odpowiada (HTTP ${response.status})`);
                    }
                } catch (error) {
                    this.addMessage('system', `❌ Błąd testowania modelu "${modelId}": ${error.message}`);
                }
            }

            toggleLoadedModelsPanel() {
                console.log('toggleLoadedModelsPanel wywołane');
                const isCollapsed = this.loadedModelsList.classList.contains('collapsed');
                console.log('Panel jest zwinięty:', isCollapsed);
                
                if (isCollapsed) {
                    // Rozwijamy panel
                    console.log('Rozwijam panel');
                    this.expandLoadedModelsPanel();
                } else {
                    // Zwijamy panel
                    console.log('Zwijam panel');
                    this.collapseLoadedModelsPanel();
                }
            }

            toggleHistoryPanel() {
                console.log('toggleHistoryPanel wywołane');
                const isCollapsed = this.historyContent.classList.contains('collapsed');
                console.log('Panel historii jest zwinięty:', isCollapsed);
                
                if (isCollapsed) {
                    // Rozwijamy panel
                    console.log('Rozwijam panel historii');
                    this.expandHistoryPanel();
                } else {
                    // Zwijamy panel
                    console.log('Zwijam panel historii');
                    this.collapseHistoryPanel();
                }
            }

            // Funkcje do bezpośredniego zwijania paneli
            collapseLoadedModelsPanel() {
                console.log('collapseLoadedModelsPanel wywołane');
                this.loadedModelsList.classList.remove('expanded');
                this.loadedModelsList.classList.add('collapsed');
                this.loadedModelsHeader.textContent = 'Rozwiń';
                this.loadedModelsPanel.classList.add('compact-panel');
                console.log('Panel załadowanych modeli został zwinięty');
            }

            collapseHistoryPanel() {
                console.log('collapseHistoryPanel wywołane');
                this.historyContent.classList.remove('expanded');
                this.historyContent.classList.add('collapsed');
                this.historyHeader.textContent = 'Rozwiń';
                this.historyPanel.classList.add('compact');
                console.log('Panel historii został zwinięty');
            }

            // Funkcje do rozwijania paneli
            expandLoadedModelsPanel() {
                console.log('expandLoadedModelsPanel wywołane');
                this.loadedModelsList.classList.remove('collapsed');
                this.loadedModelsList.classList.add('expanded');
                this.loadedModelsHeader.textContent = 'Zwiń';
                this.loadedModelsPanel.classList.remove('compact-panel');
                console.log('Panel załadowanych modeli został rozwinięty');
            }

            expandHistoryPanel() {
                console.log('expandHistoryPanel wywołane');
                this.historyContent.classList.remove('collapsed');
                this.historyContent.classList.add('expanded');
                this.historyHeader.textContent = 'Zwiń';
                this.historyPanel.classList.remove('compact');
                console.log('Panel historii został rozwinięty');
            }

            async unloadModel() {
                this.unloadModelBtn.disabled = true;
                this.unloadModelBtn.textContent = 'Wyładowywanie...';

                try {
                    this.currentModel = null;
                    this.conversationHistory = [];
                    this.updateModelStatus('unloaded', 'Model wyładowany');
                    this.loadModelBtn.disabled = false;
                    this.unloadModelBtn.disabled = true;
                    this.addMessage('system', 'Model został wyładowany. Historia konwersacji została wyczyszczona.');
                    this.updateConversationInfo();
                } finally {
                    this.unloadModelBtn.disabled = false;
                    this.unloadModelBtn.textContent = 'Wyładuj';
                    this.updateSendButtonState();
                }
            }

            updateModelStatus(status, text) {
                this.modelStatus.className = `model-status ${status}`;
                this.modelStatus.textContent = text;
                
                // Automatycznie odświeżamy listę po zmianie statusu modelu
                if (this.isConnected && (status === 'loaded' || status === 'unloaded')) {
                    setTimeout(() => this.refreshLoadedModels(), 500);
                }
            }

            populateConversationSelect() {
                this.conversationSelect.innerHTML = '<option value="new">Nowa konwersacja</option>';
                
                Object.keys(this.conversations).forEach(id => {
                    const conversation = this.conversations[id];
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${conversation.title} (${conversation.messages.length} msg)`;
                    this.conversationSelect.appendChild(option);
                });

                if (this.savedConversation && this.conversations[this.savedConversation]) {
                    this.conversationSelect.value = this.savedConversation;
                    this.currentConversationId = this.savedConversation;
                }
            }

            onConversationSelectChange() {
                const selectedId = this.conversationSelect.value;
                this.deleteConversationBtn.disabled = selectedId === 'new';
                
                if (selectedId !== this.currentConversationId) {
                    this.currentConversationId = selectedId;
                    this.saveSettings();
                    
                    if (selectedId === 'new') {
                        this.conversationHistory = [];
                        this.updateConversationInfo();
                    }
                }
            }

            createNewConversation() {
                const timestamp = new Date().toISOString();
                const id = `conv_${Date.now()}`;
                
                this.conversations[id] = {
                    id: id,
                    title: `Konwersacja ${new Date().toLocaleString('pl-PL')}`,
                    created: timestamp,
                    model: this.currentModel,
                    messages: []
                };
                
                this.currentConversationId = id;
                this.conversationHistory = [];
                
                this.saveConversations();
                this.populateConversationSelect();
                this.conversationSelect.value = id;
                this.deleteConversationBtn.disabled = false;
                
                this.clearChatDisplay();
                this.updateConversationInfo();
                this.addMessage('system', `Rozpoczęto nową konwersację: ${this.conversations[id].title}`);
            }

            async loadConversationHistory() {
                if (this.currentConversationId === 'new') {
                    this.addMessage('system', 'Wybierz konwersację z listy aby załadować jej historię.');
                    return;
                }

                const conversation = this.conversations[this.currentConversationId];
                if (!conversation) {
                    this.addMessage('system', 'Nie można znaleźć wybranej konwersacji.');
                    return;
                }

                this.conversationHistory = [...conversation.messages];
                this.displayConversationHistory();
                this.updateConversationInfo();
                
                this.addMessage('system', `Załadowano historię konwersacji: ${conversation.messages.length} wiadomości.`);
            }

            displayConversationHistory() {
                this.clearChatDisplay();
                
                this.conversationHistory.forEach(msg => {
                    this.addMessage(msg.role, msg.content, true, new Date(msg.timestamp));
                });
                
                setTimeout(() => {
                    if (window.hljs) {
                        const codeBlocks = this.chatMessages.querySelectorAll('pre code');
                        codeBlocks.forEach(block => {
                            hljs.highlightElement(block);
                        });
                    }
                }, 100);
            }

            clearCurrentConversation() {
                if (this.currentConversationId !== 'new') {
                    const conversation = this.conversations[this.currentConversationId];
                    if (conversation) {
                        conversation.messages = [];
                        this.saveConversations();
                    }
                }
                
                this.conversationHistory = [];
                this.clearChatDisplay();
                this.updateConversationInfo();
                this.addMessage('system', 'Historia obecnej konwersacji została wyczyszczona.');
                
                this.populateConversationSelect();
                this.conversationSelect.value = this.currentConversationId;
            }

            deleteConversation() {
                if (this.currentConversationId === 'new') return;

                const conversation = this.conversations[this.currentConversationId];
                if (conversation && confirm(`Czy na pewno chcesz usunąć konwersację "${conversation.title}"?`)) {
                    delete this.conversations[this.currentConversationId];
                    this.saveConversations();
                    
                    this.currentConversationId = 'new';
                    this.conversationHistory = [];
                    
                    this.populateConversationSelect();
                    this.conversationSelect.value = 'new';
                    this.deleteConversationBtn.disabled = true;
                    
                    this.clearChatDisplay();
                    this.updateConversationInfo();
                    this.addMessage('system', 'Konwersacja została usunięta.');
                }
            }

            loadSavedConversation() {
                if (this.savedConversation && this.savedConversation !== 'new' && this.conversations[this.savedConversation]) {
                    this.currentConversationId = this.savedConversation;
                    this.conversationSelect.value = this.savedConversation;
                    this.deleteConversationBtn.disabled = false;
                    this.loadConversationHistory();
                }
            }

            saveConversations() {
                if (!this.localStorageAvailable) {
                    console.warn('localStorage not available, conversations cannot be saved');
                    return;
                }
                
                try {
                    localStorage.setItem('lmstudio-conversations', JSON.stringify(this.conversations));
                } catch (error) {
                    console.error('Error saving conversations:', error);
                }
            }

            updateConversationInfo() {
                const conversation = this.conversations[this.currentConversationId];
                
                if (this.currentConversationId === 'new') {
                    this.conversationTitle.textContent = 'Konwersacja: Nowa';
                    this.messageCount.textContent = `Wiadomości: ${this.conversationHistory.length}`;
                } else if (conversation) {
                    this.conversationTitle.textContent = `Konwersacja: ${conversation.title}`;
                    this.messageCount.textContent = `Wiadomości: ${conversation.messages.length}`;
                }
                
                this.contextInfo.textContent = this.conversationHistory.length > 0 ? 
                    `Kontekst: ${this.conversationHistory.length} msg` : 'Kontekst: Pusty';
            }

            addMessage(role, content, showActions = false, timestamp = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                if (role === 'assistant') {
                    const processedContent = this.processMessageContent(content);
                    messageContent.innerHTML = processedContent;
                    
                    setTimeout(() => {
                        const codeBlocks = messageContent.querySelectorAll('pre code');
                        codeBlocks.forEach(block => {
                            if (window.hljs) {
                                hljs.highlightElement(block);
                            }
                        });
                    }, 10);
                } else {
                    messageContent.textContent = content;
                }
                
                messageDiv.appendChild(messageContent);

                if (timestamp) {
                    const timestampDiv = document.createElement('div');
                    timestampDiv.className = 'message-timestamp';
                    timestampDiv.textContent = timestamp.toLocaleString('pl-PL');
                    messageDiv.appendChild(timestampDiv);
                }

                if (showActions && role === 'assistant') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'message-actions';
                    
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'action-btn';
                    copyBtn.textContent = '📋';
                    copyBtn.title = 'Kopiuj całość';
                    copyBtn.addEventListener('click', () => {
                        navigator.clipboard.writeText(content).then(() => {
                            copyBtn.textContent = '✓';
                            setTimeout(() => copyBtn.textContent = '📋', 1000);
                        }).catch(() => {
                            const textArea = document.createElement('textarea');
                            textArea.value = content;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            copyBtn.textContent = '✓';
                            setTimeout(() => copyBtn.textContent = '📋', 1000);
                        });
                    });
                    
                    actionsDiv.appendChild(copyBtn);
                    messageDiv.appendChild(actionsDiv);
                }
                
                this.chatMessages.appendChild(messageDiv);
                this.scrollToBottom();
            }

            // ULEPSZONA FUNKCJA PRZETWARZANIA KODU - ZACHOWUJE ORYGINALNE FORMATOWANIE
            processMessageContent(content) {
                const codeBlockRegex = /```(\w+)?\s*\n?([\s\S]*?)```/g;
                let processedContent = content;
    
                processedContent = processedContent.replace(codeBlockRegex, (match, language, code) => {
                    const originalCode = code.replace(/^\n/, '').replace(/\n$/, '');
                    const lang = language ? language.toLowerCase() : 'text';
                    const langDisplayName = this.getLanguageDisplayName(lang);
                    const codeId = 'code_' + Math.random().toString(36).substr(2, 9);
        
                    return `<div class="code-compact-container" data-original-code="${this.escapeForDataAttribute(originalCode)}">
                        <div class="code-compact-header">
                            <span class="code-icon">📄</span>
                            <span class="code-info">${langDisplayName} (${originalCode.split('\n').length} linii)</span>
                            <button class="code-copy-btn" onclick="window.copyCodeBlock('${codeId}')">📋 Kopiuj</button>
                        </div>
                        <div class="code-original" id="${codeId}">${originalCode}</div>
                    </div>`;
                });
                
                if (!processedContent.includes('code-compact-container')) {
                    processedContent = processedContent.replace(/`([^`\n]+)`/g, '<code>$1</code>');
                }
    
                return processedContent.replace(/\n/g, '<br>');
                }

            getLanguageDisplayName(lang) {
                const languageNames = {
                    'javascript': 'JavaScript', 'js': 'JavaScript', 'python': 'Python', 'py': 'Python',
                    'html': 'HTML', 'css': 'CSS', 'json': 'JSON', 'sql': 'SQL', 'bash': 'Bash', 'sh': 'Shell',
                    'cpp': 'C++', 'c': 'C', 'java': 'Java', 'php': 'PHP', 'xml': 'XML', 'yaml': 'YAML',
                    'yml': 'YAML', 'markdown': 'Markdown', 'md': 'Markdown', 'text': 'Text', 'txt': 'Text'
                };
                return languageNames[lang] || lang.toUpperCase();
            }

            escapeHtml(unsafe) {
                return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }

            // Nowa funkcja do escapowania tekstu w atrybutach data-*
            escapeForDataAttribute(text) {
                return text
                    .replace(/\\/g, '\\\\')  // Escape backslashes first
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
}

            addLoadingMessage() {
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'message assistant';
                loadingDiv.id = 'loadingMessage';
                
                const loadingContent = document.createElement('div');
                loadingContent.className = 'message-content';
                loadingContent.innerHTML = `<span>AI pisze odpowiedź</span>
                    <div class="loading-dots">
                        <div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div>
                    </div>`;
                
                loadingDiv.appendChild(loadingContent);
                this.chatMessages.appendChild(loadingDiv);
                this.scrollToBottom();
            }

            removeLoadingMessage() {
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) loadingMessage.remove();
            }

            clearChatDisplay() {
                this.chatMessages.innerHTML = '';
            }

            scrollToBottom() {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            async sendMessage() {
                const message = this.messageInput.value.trim();
                if (!message || !this.isConnected || this.isGenerating || !this.currentModel) return;

                const userMessage = { role: 'user', content: message, timestamp: new Date().toISOString() };
                this.conversationHistory.push(userMessage);
                this.addMessage('user', message, false, new Date(userMessage.timestamp));
                
                this.messageInput.value = '';
                this.adjustTextareaHeight();
                this.isGenerating = true;
                this.updateSendButtonState();
                this.addLoadingMessage();

                try {
                    this.currentController = new AbortController();

                    const response = await fetch(`${this.getServerUrl()}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal: this.currentController.signal,
                        body: JSON.stringify({
                            model: this.currentModel,
                            messages: this.conversationHistory.map(msg => ({ role: msg.role, content: msg.content })),
                            temperature: 0.7,
                            max_tokens: -1,
                            stream: true
                        })
                    });

                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                    this.removeLoadingMessage();
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMessage = '';
                    let messageElement = null;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') break;

                                try {
                                    const parsed = JSON.parse(data);
                                    const content = parsed.choices?.[0]?.delta?.content;

                                    if (content) {
                                        assistantMessage += content;
                                        if (!messageElement) messageElement = this.createStreamingMessage();
                                        this.updateStreamingMessage(messageElement, assistantMessage);
                                    }
                                } catch (e) {}
                            }
                        }
                    }

                    if (messageElement && assistantMessage) {
                        this.finalizeStreamingMessage(messageElement);
                        const assistantMsg = { role: 'assistant', content: assistantMessage, timestamp: new Date().toISOString() };
                        this.conversationHistory.push(assistantMsg);
                        this.saveCurrentConversation();
                        this.updateConversationInfo();
                    }
                } catch (error) {
                    this.removeLoadingMessage();
                    if (error.name !== 'AbortError') {
                        this.addMessage('system', `Błąd: ${error.message}`);
                    } else {
                        this.addMessage('system', 'Generowanie zostało przerwane.');
                    }
                } finally {
                    this.isGenerating = false;
                    this.updateSendButtonState();
                    this.currentController = null;
                }
            }

            saveCurrentConversation() {
                // ZMIANA: Tworzymy nową konwersację TYLKO jeśli nie istnieje i mamy wiadomości do zapisania
                if (this.currentConversationId === 'new') {
                // Sprawdzamy czy mamy faktycznie jakieś wiadomości do zapisania
                    if (this.conversationHistory.length === 0) {
                        return; // Nie tworzymy pustej konwersacji
                    }
        
                    const timestamp = new Date().toISOString();
                    const id = `conv_${Date.now()}`;
        
                this.conversations[id] = {
                    id: id,
                    title: `Konwersacja ${new Date().toLocaleString('pl-PL')}`,
                    created: timestamp,
                    model: this.currentModel,
                    messages: [...this.conversationHistory]
                };
        
                this.currentConversationId = id;
                this.saveConversations();
                this.populateConversationSelect();
                this.conversationSelect.value = this.currentConversationId;
                this.deleteConversationBtn.disabled = false;
                this.updateConversationInfo();
            return;
        }

    const conversation = this.conversations[this.currentConversationId];
    if (conversation) {
        conversation.messages = [...this.conversationHistory];
        conversation.lastModified = new Date().toISOString();
        this.saveConversations();
        this.populateConversationSelect();
        this.conversationSelect.value = this.currentConversationId;
    }
}

            createStreamingMessage() {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message assistant';
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                messageDiv.appendChild(messageContent);
                
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'message-timestamp';
                timestampDiv.textContent = new Date().toLocaleString('pl-PL');
                messageDiv.appendChild(timestampDiv);
                
                this.chatMessages.appendChild(messageDiv);
                return messageDiv;
            }

            updateStreamingMessage(element, content) {
                const contentDiv = element.querySelector('.message-content');
                contentDiv.innerHTML = this.processMessageContent(content);
                
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    if (window.hljs) hljs.highlightElement(block);
                });
                
                this.scrollToBottom();
            }

            finalizeStreamingMessage(element) {
                const codeBlocks = element.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    if (window.hljs) hljs.highlightElement(block);
                });

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn';
                copyBtn.textContent = '📋';
                copyBtn.title = 'Kopiuj całość';
                copyBtn.addEventListener('click', () => {
                    const content = element.querySelector('.message-content').textContent;
                    navigator.clipboard.writeText(content).then(() => {
                        copyBtn.textContent = '✓';
                        setTimeout(() => copyBtn.textContent = '📋', 1000);
                    }).catch(() => {
                        const textArea = document.createElement('textarea');
                        textArea.value = content;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        copyBtn.textContent = '✓';
                        setTimeout(() => copyBtn.textContent = '📋', 1000);
                    });
                });
                
                actionsDiv.appendChild(copyBtn);
                element.appendChild(actionsDiv);
            }

            stopGeneration() {
                if (this.currentController) this.currentController.abort();
            }
        }

        // POPRAWIONA FUNKCJA KOPIOWANIA KODU - USUWA TAGI HTML
            window.copyCodeBlock = function(codeId) {
                const codeElement = document.getElementById(codeId);
                if (codeElement) {
                    const container = codeElement.closest('.code-compact-container');
                    const copyBtn = container.querySelector('.code-copy-btn');
        
        // Próbujemy pobrać oryginalny kod z atrybutu data-original-code
                    let codeText = container.getAttribute('data-original-code');
        
        // Jeśli nie ma atrybutu, pobieramy z textContent elementu z kodem
                    if (!codeText) {
                        codeText = codeElement.textContent;
                    }
        
        // NOWA FUNKCJA DEKODOWANIA - usuwa wszystkie tagi HTML i dekoduje entities
                    function cleanDecodeText(text) {
    // Tworzymy tymczasowy element div
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = text;

    // Zamieniamy <br> i <div> na znaki nowej linii, aby nie zgubić formatowania
                        tempDiv.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
                        tempDiv.querySelectorAll('div').forEach(div => {
                            div.replaceWith(div.textContent + '\n');
                        });

    // Pobieramy tylko tekst bez tagów HTML
                        let cleanText = tempDiv.textContent || tempDiv.innerText || '';

    // Dodatkowo dekodujemy podstawowe HTML entities
                        cleanText = cleanText
                            .replace(/&amp;/g, '&')
                            .replace(/&lt;/g, '<')
                            .replace(/&gt;/g, '>')
                            .replace(/&quot;/g, '"')
                            .replace(/&#039;/g, "'")
                            .replace(/&#39;/g, "'");

    // Usuwamy ewentualne spacje na końcu każdej linii (ładniejsze formatowanie)
                        cleanText = cleanText.replace(/[ \t]+\n/g, '\n');

                        return cleanText;
                    }
        
                    const decodedText = cleanDecodeText(codeText);
        
        // Kopiujemy do schowka
                    navigator.clipboard.writeText(decodedText).then(() => {
                        copyBtn.textContent = '✓ Skopiowano';
                        copyBtn.classList.add('copied');
                        setTimeout(() => {
                            copyBtn.textContent = '📋 Kopiuj kod';
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    }).catch(() => {
            // Fallback dla starszych przeglądarek
                        const fallbackTextArea = document.createElement('textarea');
                        fallbackTextArea.value = decodedText;
                        fallbackTextArea.style.position = 'fixed';
                        fallbackTextArea.style.left = '-9999px';
                        fallbackTextArea.style.top = '-9999px';
                        document.body.appendChild(fallbackTextArea);
                        fallbackTextArea.focus();
                        fallbackTextArea.select();
            
                        try {
                            document.execCommand('copy');
                            copyBtn.textContent = '✓ Skopiowano';
                            copyBtn.classList.add('copied');
                            setTimeout(() => {
                                copyBtn.textContent = '📋 Kopiuj kod';
                                copyBtn.classList.remove('copied');
                            }, 2000);
                        } catch (err) {
                            console.error('Nie można skopiować kodu:', err);
                            copyBtn.textContent = '❌ Błąd';
                            setTimeout(() => copyBtn.textContent = '📋 Kopiuj kod', 2000);
                        }
            
                        document.body.removeChild(fallbackTextArea);
                    });
                }
            };

        document.addEventListener('DOMContentLoaded', () => {
            const chat = new LMStudioChatV2();
            
            // Automatyczne odświeżanie listy załadowanych modeli co 30 sekund
            setInterval(() => {
                if (chat.isConnected) {
                    chat.refreshLoadedModels();
                }
            }, 30000);
            
            if (window.hljs) {
                hljs.configure({
                    ignoreUnescapedHTML: true,
                    languages: ['python', 'javascript', 'html', 'css', 'json', 'sql', 'bash', 'cpp', 'java', 'php']
                });
            }
        });
    </script>
</body>
</html>